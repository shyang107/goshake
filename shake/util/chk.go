package util

import (
	"fmt"
	"path"
	"runtime"
	"strings"

	"github.com/shyang107/go-twinvoices/pencil/ansi8"
)

// Panic panicks
func Panic(msg string, prm ...interface{}) {
	CallerInfo(4)
	CallerInfo(3)
	CallerInfo(2)
	panic(fmt.Sprintf(msg, prm...))
}

// CallerInfo returns the file and line positions where an error occurred
//  idx -- use idx=2 to get the caller of Panic
func CallerInfo(idx int) {
	pc, file, line, ok := runtime.Caller(idx)
	if !ok {
		file, line = "?", 0
	}
	var fname string
	f := runtime.FuncForPC(pc)
	if f != nil {
		fname = f.Name()
	}
	if Verbose {
		// fmt.Printf("file = %s:%d\n", file, line)
		// fmt.Printf("func = %s\n", fname)
		fmt.Printf("file = %s:%d -- func = %s\n", file, line, fname)
	}
}

// GetErrMessage get error message if error
func GetErrMessage(err error) string {
	if err != nil {
		return fmt.Sprintf("Error is :'%s'", err.Error())
	}
	return "Notfound this error"
}

// CheckErr check error
func CheckErr(err error) {
	if err != nil {
		// perr(getErrMessage(err))
		panic(err)
	}
}

// Err returns a new error
func Err(msg string, prm ...interface{}) error {
	return fmt.Errorf(msg, prm...)
}

// FuncCallerInfo describes the information of callers of function
type FuncCallerInfo struct {
	PackageName string
	FileName    string
	FuncName    string
	Line        int
}

// RetrieveCallerInfo retrieve the information of callers of function
func RetrieveCallerInfo(idx int) *FuncCallerInfo {
	pc, file, line, _ := runtime.Caller(idx)
	_, fileName := path.Split(file)
	parts := strings.Split(runtime.FuncForPC(pc).Name(), ".")
	pl := len(parts)
	packageName := ""
	funcName := parts[pl-1]

	if parts[pl-2][0] == '(' {
		funcName = parts[pl-2] + "." + funcName
		packageName = strings.Join(parts[0:pl-2], ".")
	} else {
		packageName = strings.Join(parts[0:pl-1], ".")
	}

	return &FuncCallerInfo{
		PackageName: packageName,
		FileName:    fileName,
		FuncName:    funcName,
		Line:        line,
	}
}

// CallerName return the name of function calling
func CallerName(idx int) string {
	// pc, _, _, _ := runtime.Caller(idx) //idx = 0 self, 1 for caller, 2 for upper caller
	// msg := runtime.FuncForPC(pc).Name()
	ci := RetrieveCallerInfo(idx + 1)
	// if ci.fileName == "<autogenerated>" {
	// 	return Sf("package: %s:%d; func: %s",
	// 		LogColorString("debug", ci.packageName),
	// 		LogColorString("info", Sf("%d", ci.line)),
	// 		LogColorString("debug", ci.funcName),
	// 	)
	// }
	// return Sf("file: %s:%s; func: %s",
	// 	LogColorString("debug", ci.fileName),
	// 	LogColorString("info", Sf("%d", ci.line)),
	// 	LogColorString("debug", ci.funcName),
	// )
	// return Sf("file: %s:%d; func: %s", ci.FileName, ci.Line, ci.FuncName)
	return Sf("file: %s:%v; func: %s",
		ci.FileName,
		LogColorStringFuncs["debug2"](ci.Line),
		LogColorStringFuncs["debug2"](ci.FuncName),
	)
}

// Startfunc print the message at the start of function
func Startfunc(fid int) {
	Pfstart(Format[fid], CallerName(2))
}

// Stopfunc print the message at the start of function
func Stopfunc(fid int) {
	Pfstop(Format[fid], CallerName(2))
	PrintSepline(60)
}

// DebugPrintCaller print the name of function called and calling
func DebugPrintCaller() {
	// msg := Sf("▶ %q called by %q", CallerName(2), CallerName(3))
	// Glog.Debug(msg)
	if Glog.Printer.IsTerminal {
		Glog.Debugf("▶ [%s] called by [%s]",
			ansi8.HiYellowString(CallerName(2)), ansi8.YellowString(CallerName(3)))
	} else {
		Glog.Debugf("▶ [%s] called by [%s]", CallerName(2), CallerName(3))
	}
}
